__1.Исследование структуры пакета
а. Дополните схему дерева файлов и модулей пакета calculator, указав, какие модули и функции в них содержатся.__
```
calculator/
├── __init__.py
├── basic/
│   ├── __init__.py
│   ├── addition.py
│   │   └── def add
│   └── subtraction.py
│       └── def subtract
└── advanced/
    ├── __init__.py
    ├── exponentiation.py
    │   └── def power
    └── root.py
        └── def square_root
```
__б. Объясните, какую роль играют файлы `__init__.py` в каждом каталоге пакета. Почему без них пакет не будет работать правильно?__

Без `__init.py__` Python не сможет правильно импортировать модули из этого каталога, так как этот файл является пакетом-проводником, а не обычной папкой. Внутри данного файла можно указывать, какие модули или функции доступны для импорта.

__2. Работа с `__init__.py`
а. Обратите внимание на использование переменной `__all__` в файле calculator/`__init__.py`. Объясните, как она влияет на импорт пакета.__

Данная переменная определяет, какие модули будут импортироваться при использовании конструкции from calculator import *. В данном случае, `__all__` = ["basic", "advanced"] означает, что при импорте пакета calculator будут доступны только эти два подкаталога (basic и advanced), а все остальные модули или файлы игнорируются. Если даннная переменная не указана, то Python импортирует все модули, которые есть в пакете, кроме тех, что начинаются с подчеркивания (_).

__б. Удалите или закомментируйте строку `__all__` = ["basic", "advanced"] в файле calculator/`__init__.py`. Попробуйте импортировать пакет снова:__
`from calculator import basic`
__Что произошло? Объясните причину возникшей проблемы.__

При попытке выполнить импорт возникла ошибка, так как отсутствует список доступных для импорта модулей. Python не может найти каталог basic в пакете calculator.

__в. Верните строку `__all__` обратно. Попробуйте выполнить команду:__
`from calculator import *`
__Какие модули будут импортированы? Как можно управлять импортируемыми модулями с помощью `__all__`?__

Будут импортированы только модули basic и advanced. При использовании from calculator import *, Python будет импортировать только те модули, которые перечислены в all.

__3. Абсолютный и относительный импорт__
__а. В файле `calculator/basic/__init__.py` замените относительные импорты на абсолютные:__


`from calculator.basic.addition import add`
`from calculator.basic.subtraction import subtract`
__Проверьте работоспособность пакета. Объясните разницу между относительным и абсолютным импортом. Какие преимущества и недостатки каждого из них?__

Работает. Абсолютный импорт использует полный путь, а относительный импорт указывает путь относительно текущего файла. Абсолютный импорт нагляднее, но длиннее, чем относительный.

__б. Предположим, что структура пакета изменилась, и папка basic была переименована в simple. Объясните, как это повлияет на абсолютные и относительные импорты. Какой импорт легче поддерживать при реорганизации структуры пакета?__

Абсолютные импорты перестанут работать. Чтобы это исправить, нужно заменить папку basic на simple. Относительные импорты могут не изменятся. Например from .root import square_root останется рабочим.

__4. Добавление новых модулей
а. Добавьте в пакет `calculator/basic` новый модуль `multiplication.py` с функцией multiply(a, b), которая возвращает произведение a и b.__
```
calculator/
├── __init__.py
├── basic/
│   ├── __init__.py
│   ├── addition.py
│   └── multiplication.py
│   └── subtraction.py
└── advanced/
    ├── __init__.py
    ├── exponentiation.py
    └── root.py
```
__б. Обновите файл `calculator/basic/__init__.py`, чтобы функция multiply была доступна при импорте пакета.__

`from calculator.basic.multiplication import multiply`

__в. В файле main.py импортируйте новую функцию и протестируйте ее.__

from calculator.basic import multiply

print(multiply(4, 5))        # Вывод: 20
20

5. Исследование переменной `__name__`
__а. В файле calculator/advanced/exponentiation.py добавьте следующий код:__

if `__name__ == "__main__"`:
    print(power(2, 5))
__б. Запустите файл exponentiation.py напрямую. Что произошло? Какой вывод вы получили?__

Приведённый код позволяет определять точку входа в программу. Вывод - 32

__в. Импортируйте функцию power в main.py и запустите main.py. Выполняется ли код внутри блока if `__name__ == "__main__"`: в файле exponentiation.py при импорте? Объясните, почему.__

Код в файле exponentiation.py не выполнился, так как при импорте функции в файле main.py переменная name принимает значение имени модуля, не как значение основного файла. Код в блоке if name == "main" выполняется, когда файл запускается напрямую.

__6. Изучение путей поиска модулей
а. Выведите переменную sys.path в main.py:__

import sys
print(sys.path)
Объясните, какие пути в ней содержатся и как Python использует их для поиска модулей.

Текущую директорию, из которой был запущен скрипт. Директории, указанные в переменной окружения PYTHONPATH. Стандартные директории, в которых установлены системные пакеты Python.

__б. Попробуйте переместить папку calculator в другую директорию, которая не входит в sys.path. Можете ли вы теперь импортировать пакет? Что нужно сделать, чтобы Python мог найти ваш пакет?__

Не получилось импортировать пакет. Чтобы найти его, можно добавить новый путь в sys.path прямо в скрипте, установить переменную окружения PYTHONPATH перед запуском кода.

__7. Создание подпакетов__
а. Внутри calculator/advanced создайте подпакет trigonometry с функциями sin, cos и tan. Структура должна выглядеть так:
```
calculator/
└── advanced/
    ├── trigonometry/
    │   ├── __init__.py
    │   ├── sine.py
    │   ├── cosine.py
    │   └── tangent.py
  ```  
__б. Реализуйте функции в соответствующих модулях, используя модуль math из стандартной библиотеки Python.__

__в. Обновите `__init__.py` файлы, чтобы обеспечить корректный импорт функций.__

__г. Импортируйте функции в main.py и протестируйте их.__

__8. Практика с относительным импортом__
__а. В файле `calculator/advanced/trigonometry/sine.py` попробуйте импортировать функцию square_root из модуля root.py двумя способами:__

__Используя относительный импорт.__
__Используя абсолютный импорт.__
__б. Объясните, какой способ импорта сработал, а какой нет, и почему.__

Относительный импорт не сработает, так как они работают только внутри пакетов. Абсолютный импорт сработает всегда, так как всегда указывает полное местоположение модуля. В данном случае нам необходимо подняться на пакет выше, поэтому лучше использовать абсолютный путь.
